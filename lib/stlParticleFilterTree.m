function [ results ] = stlParticleFilterTree(sbmlModel, data, opts, varargin )
% STLPARTICLEFILTERTREE	performs the bootstrap particle filter on tree-structured data
%
% sbmlModel ... SBML structure (loaded by libSBML)
% data ... data structure (_time_, _cellNr_, _inspected_, plus observed species/noise)
% opts ... options structure generated by stlOptions
% varargin{1} ... fixed parameteres
%
% The result structure contains
% c ... samples of the particles from the posterior
% w ... weights of the samples
% alpha ... parameter of the gamma posterior distribution for each particle
% beta ... parameter of the gamma posterior
% Q ... quantiles of system state
% obs ... original data structure re-formated in cell oriented way
%
% See also stlOptions

    Priors = cell2mat({opts.Parameters.GammaPrior}');
    PNr = opts.ParticleNr;
    CNr = length(unique(data.cellNr));
    
    if (~isempty(varargin))
        SampleParameters = 0;
        FixedParameters = repmat(varargin{1}, [PNr, 1]);
        
        % dont save anything or plot anything
        opts.Save=0;
        opts.SavePlotsWhileFiltering=0;
        opts.SaveX=0;
        opts.SavePlotsWhileFiltering=0;
        opts.ShowPlotsWhileFiltering=0;        
    else
        SampleParameters = 1;
    end
    
    if (opts.Save || opts.SavePlotsWhileFiltering || opts.SaveX)
        prepareDirectories(opts.OutDir);
    end

    initFunc = opts.fInitParticleSpecies;
    forwardSim = opts.fSimulate;
    timepoints = unique(data.time);
    dt = diff(timepoints);
    intermTNo = opts.LatentQuantilesPerTimestep;
    latentQuantiles = opts.LatentQuantiles;
    
    %% define forward simulation
    ThNr = length(sbmlModel.parameter);
    observedSpecies = find(cellfun(@(c) c==true, {opts.Species.Observed}));

    %% split the data into distinct cells
    obs = stlConvertDataToObs( data, opts );
    
    % Init tracked quantiles
    cellNrs = unique([data(:).cellNr]);
    Q = cell(length(cellNrs),2);
    for k=1:CNr
        Q{k,1} = zeros((length(obs.time{k})-1)*(intermTNo)+1, length(opts.Species), length(latentQuantiles));
        Q{k,2} = zeros((length(obs.time{k})-1)*(intermTNo)+1,1);         
    end


    %% create the MJP posteriors for each particle
    alpha = repmat(Priors(:,1)',PNr,1);
    beta = repmat(Priors(:,2)',PNr,1);

    %% determine the minimum/maximum time in the data
    t_min = inf;
    t_max = 0;
    for k=1:CNr
        t_min = min(t_min, min(obs.time{k}));
        t_max = max(t_max, max(obs.time{k}));
    end

    TNr = length(unique(timepoints));
    %% determine which cells are alive at first time point
    cells = unique(data.cellNr(find(data.time == timepoints(1))));

    % initialize those cells
    X = cell(length(cells),1);
    curQ = [];
    for k=1:length(cells)
        cell_ix = find(obs.cellNr == cells(k));
        % observed intensities for this cell
        observed1 = zeros(1,length(observedSpecies));
        sigma1 = zeros(1,length(observedSpecies));
        for sIdx=1:length(observedSpecies)
            observed1(sIdx) = obs.(opts.Species(observedSpecies(sIdx)).Name){cell_ix}(1);
            sigma1(sIdx) = obs.([opts.Species(observedSpecies(sIdx)).Name 'Sigma']){cell_ix}(1);
        end
        X{k} = initFunc(PNr, observed1, sigma1, opts);
    end
    
    w1 = computeWeights(0, X, obs, timepoints, cells, observedSpecies, opts);
    meanW = zeros(TNr,1);
    meanW(1) = log(mean(exp(sum(w1,2))));
    
    %% Initial conditions were sampled according observed data 
    samples = 1:PNr;

    %% Apply / detect number of parallel workers
    if (isfield(opts, 'ParallelWorkers') && ~isempty(opts.ParallelWorkers))
        numWorkers = opts.ParallelWorkers;
    else
        pp = gcp('nocreate');
        if (~isempty(pp))
            numWorkers = pp.NumWorkers;
        else
            numWorkers = 1;
        end
        disp(['Number of parallel workers detected: ' num2str(numWorkers)]);
    end
    
    curQ = cell(length(cells),2);
    for k=1:length(cells)
        curQ(k,:) = Q(cells(k),:);
    end  

    %% loop over time    
    for i=1:TNr-1

        if SampleParameters % don't output iteration # when doing the GOF test
            fprintf('i=%d\n',i)
        end

        % sample the particles for the next iteration
        N_cells = length(cells);
        
        c = cell(1,N_cells);
        for k=1:N_cells
            if (SampleParameters)
                c{k} = gamrnd(alpha, 1./beta); % P samples
            else
                c{k} = FixedParameters;
            end
        end
        
        % init.
        r=zeros(PNr,ThNr);
        int_g=zeros(PNr,ThNr);    

        % Store starting quantile
        for k=1:N_cells
            tIdxOffset = find(timepoints(i) == obs.time{cells(k)});
            curQ{k,1}((tIdxOffset-1)*(intermTNo)+1,:,:) = quantile(X{k}, latentQuantiles)';
            curQ{k,2}((tIdxOffset-1)*(intermTNo)+1) = timepoints(i);        
        end
        
        %% simulate all cells forward
        for k=1:N_cells
            X{k} = X{k}(samples,:);
        end
        ChunkSize = ceil(PNr/numWorkers);
        J=numWorkers;
        intermT = linspace(0, dt(i), intermTNo+1);
        for itIdx = 1:intermTNo
            curDt = diff(intermT([itIdx itIdx+1]));
            for k=1:N_cells
                if SampleParameters
                    tic
                end
                Xout_j   = cell(1,J);
                r_k_j    = cell(1,J);
                int_g_k_j= cell(1,J);
                X_k_j   = cell(1,J);
                c_k_j   = cell(1,J);

                % prechunk to avoid broadcasting the whole arrays
                for j=1:J
                    ix = ((j-1)*ChunkSize +1):( min(j*ChunkSize,PNr));
                    X_k_j{j} = X{k}(ix,:);
                    c_k_j{j} = c{k}(ix,:);
                end

                parfor j=1:J
                    [tmpX, ~, tmpR, tmpG] = forwardSim(X_k_j{j}, c_k_j{j}, curDt);
                    Xout_j{j} = squeeze(tmpX(end,:,:))';
                    r_k_j{j} = squeeze(tmpR(:,end,:))';
                    int_g_k_j{j} = squeeze(tmpG(:,end,:))';
                end

                Xout = vertcat(Xout_j{:});
                r_k  = vertcat(r_k_j{:});
                int_g_k = vertcat(int_g_k_j{:});
                if SampleParameters
                    toc
                end
                r = r+r_k;
                int_g = int_g+int_g_k;
                X{k} = Xout;
                
                tIdxOffset = find(timepoints(i) == obs.time{cells(k)});
                curQ{k,1}((tIdxOffset-1)*(intermTNo)+itIdx+1,:,:) = quantile(X{k}, latentQuantiles)';
                curQ{k,2}((tIdxOffset-1)*(intermTNo)+itIdx+1) = timepoints(i) + intermT(itIdx+1);
            end
        end
        
        % Store quantiles
        for k=1:N_cells
            Q(cells(k),:) = curQ(k,:);
        end
        
         %% allocation to daughter cells
        cells_i = unique(data.cellNr(find(data.time == timepoints(i+1)))); % cells alive at the next time point

        if (~isequal(cells, cells_i))
            % check which cells were not there in the last iteration
            new_cells = setdiff(cells_i, cells);
            % cells from previous iteration still at current iteration
            old_cells = setdiff(cells_i, new_cells);
            % copy the latent trajectories from the old cells
            X_new = cell(1,length(old_cells));

            for k=1:length(old_cells)
                ix = find(cells==old_cells(k));
                X_new{k} = X{ix};
            end   

            % new cells, not in previous iteration
            new_cells_queue = new_cells;
            k = length(old_cells)+1;

            while ~isempty(new_cells_queue)
                % if the mother cell is there, then initialize from its last state
                nc = new_cells_queue(1);
                mother = floor(nc/2);
                if (find(cells==mother))
                    % check for sister cell
                    if mod(nc,2)==0
                        % even
                        sister = nc+1;
                    else
                        % odd
                        sister = nc-1;
                    end

                    if (find(new_cells == sister))
                        % sister is there, so allocate mother to both daughters
                        mother_id = find(cells==mother);
                        sister1Id = k;
                        sister2Id = k+1;
                        k = k + 2;

                        [X_new{sister1Id} X_new{sister2Id}] = stlSimulateCellDivision(X{mother_id}, opts);
                        
                        new_cells_queue = setdiff(new_cells_queue, [nc, sister]);
                    else
                        error('Not implemented yet');
                    end
                end
            end

            X = X_new;
            cells = [old_cells; new_cells];

            curQ = cell(length(cells),2);            
            for k=1:length(cells)
                curQ(k,:) = Q(cells(k),:);
            end                
            
        end
        
        %% compute weights of all cells given the observations
        w = computeWeights(i, X, obs, timepoints, cells, observedSpecies, opts);

        w = sum(w,2); % reduce across data sets
        w_raw = w;
        w = exp(w - max(w));  % shift for numerical reasons before returning from log-space

        % update posteriors  
        alpha = alpha + r;
        beta  = beta + int_g;

        % sample new particles
        samples = discretesample(w/sum(w),PNr);

        if (SampleParameters)
            alpha = alpha(samples,:);
            beta = beta(samples,:);
            c = gamrnd(alpha,1./beta);
        else
            c = FixedParameters;
        end
        
        meanW(i+1) = log(mean(exp(w_raw-max(w_raw))))+max(w_raw);
               
        if (opts.SaveX)
            % save the statistics of the accepted particles latent trajectories
            clear f x
            for k=1:length(cells)
                for sIdx = 1:length(opts.Species)
                    [f.(opts.Species(sIdx).Name){k},x.(opts.Species(sIdx).Name){k}] = ksdensity(X{k}(samples,sIdx));
                end
            end
            save([opts.OutDir, '/stats/stats_', int2str(i), '.mat'], 'f', 'x');
        end
        
        if (opts.SavePlotsWhileFiltering || opts.ShowPlotsWhileFiltering )
            stlPlotTracking(X, obs, cells, samples, timepoints, observedSpecies, sbmlModel, opts, i);
            stlPlotPosterior(c, sbmlModel, opts, i);
            stlPlotSampleFrequencies(samples, sbmlModel, opts, i);
            stlPlotTimecourseSpeciesQuantiles(sbmlModel, obs, opts, Q, i);
        end


    end
    results = struct('c', c, 'w', w, 'alpha', alpha, 'beta', beta, 'Q', {Q}, 'obs', obs, 'meanLogLik', meanW, 'margLogLik', sum(meanW), 'data', data);
    if (opts.Save)
        save(fullfile(opts.OutDir,'results'), '-struct', 'results');
    end
end

function [w] = computeWeights(iteration, X, obs, timepoints, cells, observedSpecies, opts)
    PNr = size(X{1},1);
    w = zeros(PNr,length(cells));
    for k = 1:length(cells)
        % compute weight of particles = log likelihood
        cell_id = find(obs.cellNr==cells(k));
        ix = find(obs.time{cell_id} == timepoints(iteration+1));  
        if ~isempty(ix)
            if obs.inspected{cell_id}(ix)==1
                observed = zeros(1,length(observedSpecies));
                sigma = zeros(1,length(observedSpecies));
                for sIdx = 1:length(observedSpecies)
                    observed(sIdx) = obs.(opts.Species(observedSpecies(sIdx)).Name){cell_id}(ix);
                    sigma(sIdx) = obs.([opts.Species(observedSpecies(sIdx)).Name 'Sigma']){cell_id}(ix);
                end
                w(:,k) = sum(- 0.5*log(2*pi) - repmat(log(sigma),[PNr,1]) - 0.5*( (repmat(observed,[PNr,1])-X{k}(:,observedSpecies)).^2 ./ repmat(sigma.^2,[PNr,1])),2);
            else
                w(:,k) = 0; % equal probability
            end
        end
    end
end

% Generates all output (sub-)directories of opts.OutDir
function prepareDirectories(saveDir)
    if (~exist(saveDir,'dir'))
        mkdir(saveDir)
    end
    if (~exist([saveDir,'/posterior'],'dir'))
        mkdir([saveDir,'/posterior'])
    end
    if (~exist([saveDir,'/tracking'],'dir'))
        mkdir([saveDir,'/tracking'])
    end    
    if (~exist([saveDir,'/mat'],'dir'))
        mkdir([saveDir,'/mat'])
    end    
    if (~exist([saveDir,'/frequencies'],'dir'))
        mkdir([saveDir,'/frequencies'])
    end    
    if (~exist([saveDir,'/stats'],'dir'))
        mkdir([saveDir,'/stats'])
    end    
    if (~exist([saveDir,'/speciesquantiles'],'dir'))
        mkdir([saveDir,'/speciesquantiles'])
    end   
    if (~exist([saveDir,'/speciesquantilestree'],'dir'))
        mkdir([saveDir,'/speciesquantilestree'])
    end       
end
